import configparser
import datetime
from functools import lru_cache
from random import randint
import uuid
from fuzzywuzzy import fuzz, process
from nltk.stem.snowball import RussianStemmer
from bot.editors import edit_product_message
from bot.emoji import CATEGORY_NAMES, CATEGORY_EMOJIS
from bot.markups import back_skip_markup, check_markup

def find_emoji_fuzzy(dish_name, threshold=70):
    flat_category_names = []
    category_map = {}

    for category, names in CATEGORY_NAMES.items():
        for name in names:
            flat_category_names.append(name)
            category_map[name] = category

    match = process.extractOne(dish_name, flat_category_names, scorer=fuzz.partial_ratio)
    if match and match[1] >= threshold:
        matched_category = category_map[match[0]]
        return CATEGORY_EMOJIS.get(matched_category, CATEGORY_EMOJIS["–ø—Ä–æ—á–µ–µ"])

    return CATEGORY_EMOJIS["–ø—Ä–æ—á–µ–µ"]

@lru_cache(maxsize=1000)
def stem_text(text):
    stemmer = RussianStemmer()
    return stemmer.stem(text)

def find_categories_fuzzy(dish_name, dish_categories, threshold=70, limit=5):
    # –ü—Ä–æ–π–¥–µ–º –ø–æ –≤—Å–µ–º –±–ª—é–¥–∞–º –∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º fuzzywuzzy –¥–ª—è –ø–æ–∏—Å–∫–∞ –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ—Ö–æ–∂–∏—Ö
    stemmer = RussianStemmer()
    stemmed_dish_name = stem_text(dish_name)
    matches = process.extract(
        stemmed_dish_name,
        [info["all_info"] for info in dish_categories.values()],
        scorer=fuzz.partial_ratio,
        limit=limit
    )

    # –£—á–∏—Ç—ã–≤–∞–µ–º –¥–ª–∏–Ω—É —Å—Ç—Ä–æ–∫–∏
    def length_adjusted_score(match):
        match_text, score = match
        length_difference = abs(len(stemmed_dish_name) - len(match_text))
        # –£–º–µ–Ω—å—à–∞–µ–º –æ—Ü–µ–Ω–∫—É –∑–∞ –±–æ–ª—å—à–æ–µ —Ä–∞—Å—Ö–æ–∂–¥–µ–Ω–∏–µ –≤ –¥–ª–∏–Ω–µ
        adjusted_score = score - length_difference
        return adjusted_score

    # –û—Ç—Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –æ—Ü–µ–Ω–∫–∞–º
    matches = sorted(matches, key=length_adjusted_score, reverse=True)

    # –ü—Ä–æ–π–¥–µ–º –ø–æ –≤—Å–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –ø–æ—Ä–æ–≥—É —Å—Ö–æ–∂–µ—Å—Ç–∏
    for match in matches:
        best_match_info, score = match
        if score >= threshold:
            # –ù–∞–π–¥–µ–º –∫–ª—é—á –±–ª—é–¥–∞, –∫–æ—Ç–æ—Ä–æ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –Ω–∞–π–¥–µ–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–µ
            best_match_dish = [dish for dish, info in dish_categories.items() if info["all_info"] == best_match_info][0]
            return dish_categories[best_match_dish]["categories"]

    return []

def check_user_state(state=True):
    def decorator(bot, func):
        async def wrapper(message, *args, **kwargs):
            from utils.database import read_json
            user_data = read_json()  # –ß–∏—Ç–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–∑ —Ñ–∞–π–ª–∞
            user_id = str(message.from_user.id)  # –ü—Ä–∏–≤–æ–¥–∏–º –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∫ —Å—Ç—Ä–æ–∫–µ
            if user_id in user_data:
                if user_data[user_id].get('enabled') == state:
                    return func(message, *args, **kwargs)  # –í—ã–ø–æ–ª–Ω—è–µ–º –æ—Å–Ω–æ–≤–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
                else:
                    await bot.send_message(message.chat.id, "–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω.")
            else:
                await bot.send_message(message.chat.id, "–ü–æ–∫–∞ –Ω–µ –Ω–∞–∂–º—ë—Ç–µ /start, —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ –±—É–¥–µ—Ç.")
        return wrapper
    return decorator

def check_if_correct_data(data):
    for product in data:
        if isinstance(product.get("manufacture_date"), datetime.date):
            product["manufacture_date"] = product["manufacture_date"].isoformat()
        if isinstance(product.get("expiry_date"), datetime.date):
            product["expiry_date"] = product["expiry_date"].isoformat()
    return data

def notify_and_delete_expired_product(product_id, product):
    from utils.database import write_json
    if product:
        # –£–¥–∞–ª—è–µ–º –ø—Ä–æ–¥—É–∫—Ç –∏–∑ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞
        
        product.remove(product["product_id"])
        write_json(product)

        # –†–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —ç—Ç–æ–º –ø—Ä–æ–¥—É–∫—Ç–µ
        edit_product_message(product_id, "üí§ –£–∂–µ –Ω–µ–∞–∫—Ç—É–∞–ª—å–Ω–æ - –ø—Ä–æ—à–ª–æ —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏")

def add_new_weight_change(weight, chat_id):
    from config import new_products
    from event_handlers import products_stream
    from utils.database import read_json, write_json
    product_id = str(uuid.uuid4())
    timestamp = datetime.datetime.now()
    products = read_json(new_products)
    if products is None:
        products = {}
    products[product_id] = {
        "weight": weight,
        "status": "waiting",  # waiting, in_progress, registered
        "user_id": None,
        "timestamp": timestamp,
        "message_id": None,  # ID —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        "chat_id": chat_id
    }
    write_json(new_products, products)
    products_stream.on_next((product_id, "waiting"))

    return product_id

# –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø—Ä–æ–¥—É–∫—Ç–∞
async def start_adding_food(bot, message):
    from message_handler import registration_sessions
    product_id = str(uuid.uuid4())  # –£–Ω–∏–∫–∞–ª—å–Ω—ã–π ID
    registration_sessions[message.chat.id] = {
        "state": "waiting_for_name",
        "product": {
            "id": product_id,
            "name": "",
            "categories" : [],
            "weight": 0,  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
            "tare_weight": 0,  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
            "source": "–ú–∞–≥–∞–∑–∏–Ω",  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
            "manufacture_date": datetime.date.today(),  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é - —Å–µ–≥–æ–¥–Ω—è
            "expiry_date": None,
        }
    }
    await bot.send_message(message.chat.id, "–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ–¥—É–∫—Ç–∞:", reply_markup=back_skip_markup)

async def notify_others_about_product(bot, product_id, registering_user_id):
        from config import new_products, users
        from utils.database import read_json
        product = read_json(new_products).get(product_id)
        if not product:
            return  # –ü—Ä–æ–¥—É–∫—Ç —É–∂–µ —É–¥–∞–ª–µ–Ω –∏–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç

        # –ß–∏—Ç–∞–µ–º —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        user_data = read_json(users)
        user_ids = [int(user_id) for user_id in user_data.keys()]

        # –ò—Å–∫–ª—é—á–∞–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_ids = [user_id for user_id in user_ids if user_id != registering_user_id]
        # –¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
        product_info = get_summary(product,find_emoji_fuzzy(product["categories"]), title=f"‚úÖ –ù–æ–≤—ã–π –ø—Ä–æ–¥—É–∫—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ –±–∞–∑—É!\n")

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤—Å–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º
        for user_id in user_ids:
            try:
                await bot.send_message(user_id, product_info)
            except Exception as e:
                print(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")
                
def get_random_weight(a,b):
    return randint(a, b)

def get_summary(product, category_emoji, title):
    return (
        title,
        f"üìå **–ù–∞–∑–≤–∞–Ω–∏–µ:** {product['name']}\n"
        f"{category_emoji} **–ö–∞—Ç–µ–≥–æ—Ä–∏—è:** {product['categories']}\n"
        f"‚öñÔ∏è **–í–µ—Å:** {product['weight']} –≥\n"
        f"üì¶ **–í–µ—Å —Ç–∞—Ä—ã:** {product['tare_weight']} –≥\n"
        f"üè∑Ô∏è **–ò—Å—Ç–æ—á–Ω–∏–∫ (–∫—Ç–æ –ø—Ä–∏–≥–æ—Ç–æ–≤–∏–ª):** {product['source']}\n"
        f"üìÖ **–î–∞—Ç–∞ –∏–∑–≥–æ—Ç–æ–≤–ª–µ–Ω–∏—è:** {product['manufacture_date'].strftime('%d.%m.%Y')}\n"
        f"‚è≥ **–ì–æ–¥–µ–Ω –¥–æ:** {product['expiry_date'].strftime('%d.%m.%Y')}\n"
    )

async def send_product_summary(bot, chat_id, product):
    category_emoji = find_emoji_fuzzy(product["categories"])
    summary = get_summary(product,category_emoji, title="üìù **–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–∞–Ω–Ω—ã–µ –ø—Ä–æ–¥—É–∫—Ç–∞:**\n")
    await bot.send_message(chat_id, summary, parse_mode="Markdown", reply_markup=check_markup)

def create_config():
    # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç ConfigParser
    config = configparser.ConfigParser()
    
    # –î–æ–±–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –±–µ–∑ —Å–µ–∫—Ü–∏–π
    config['DEFAULT'] = {
        'admin_id': '699861867',
        'bot_token': "7223871421:AAG2IKwKcGALr5UUYbs15LI9ndd8xpS1FpQ",
        'sessions_file': 'data/registration_sessions.json',
        'fridge': 'data/fridge_data.json',
        'users': 'data/users.json',
        'new_products': 'data/new_products.json',
        'interactive': 'data/state.json',
        'dishes': 'data/dishes.txt'
    }
    
    # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –≤ —Ñ–∞–π–ª
    with open('config.ini', 'w') as configfile:
        config.write(configfile)

def read_config():
    # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç ConfigParser
    config = configparser.ConfigParser()

    # –ß–∏—Ç–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏–∑ —Ñ–∞–π–ª–∞
    config.read('config.ini')

    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Å–ª–æ–≤–∞—Ä—å
    config_data = dict(config['DEFAULT'])

    return config_data